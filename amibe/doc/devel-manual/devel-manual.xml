<?xml version = '1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
  <!-- shortcuts for OTriangle endpoints -->
  <!ENTITY o "<varname>o</varname>">
  <!ENTITY d "<varname>d</varname>">
  <!ENTITY a "<varname>a</varname>">
  <!ENTITY n "<varname>n</varname>">
  <!-- shortcut for an OTriangle instance -->
  <!ENTITY ot "<varname>ot</varname>">
  <!-- shortcut for a Triangle instance -->
  <!ENTITY t "<varname>t</varname>">
  <!-- shortcut for a Triangle instance -->
  <!ENTITY TRI "<classname>Triangle</classname>">
  <!ENTITY OTRI "<classname>OTriangle</classname>">
  <!-- shortcut for a Vertex.outer field -->
  <!ENTITY VOUTER "<classname>Vertex.</classname><structfield>outer</structfield>">
  <!-- shortcut for "true" and "false" constants -->
  <!ENTITY true "<constant>true</constant>">
  <!ENTITY false "<constant>false</constant>">
]>
<book>
  <title>Amibe Development Manuel</title>
  <bookinfo>
  <author>
    <firstname>Denis</firstname>
    <surname>Barbier</surname>
    <email>barbier@linuxfr.org</email>
  </author>
  <releaseinfo>
    Based on CVS version 2005-11-30
  </releaseinfo>
  </bookinfo>
  <chapter>
    <title>Introduction</title>
  <para>
    What is jCAE?
    FIXME
  </para>
  </chapter>

  <chapter>
    <title>Overview of Data Structures</title>
  <para>
We describe here some data structures commonly used in meshing programs.
They all apply on 2-manifold objects, the case of non-manifold
geometries will be addressed in further versions of this document.
  </para>

  <para>
Their goal is to provide adjacency relations between elements.
For instance one can use the following sets, as defined by
<ulink url="http://ocw.mit.edu/NR/rdonlyres/Ocean-Engineering/13-472JComputational-GeometrySpring2003/22CDF275-157E-4067-99F3-A3224D2D0A26/0/lecnotes14_fixed.pdf">Nicholas M. Patrikalakis</ulink>
<variablelist spacing="compact">
  <varlistentry>
    <term>V(F)</term>
    <listitem><simpara>list of triangles adjacent to a vertex</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>V(E)</term>
    <listitem><simpara>list of edges adjacent to a vertex</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>V(V)</term>
    <listitem><simpara>list of neighbour vertices</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>E(F)</term>
    <listitem><simpara>list of triangles adjacent to an edge (1 for a boundary
           edge, 2 otherwise.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>E(E)</term>
    <listitem><simpara>list of edges adjacent to an edge (unused?)</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>E(V)</term>
    <listitem><simpara>the two endpoints of this edge</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>F(F)</term>
    <listitem><simpara>list of faces adjacent to a face (unused?)</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>F(E)</term>
    <listitem><simpara>the three edges of a triangle</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term>F(V)</term>
    <listitem><simpara>the three vertices of this triangle</simpara></listitem>
  </varlistentry>
</variablelist>

It is sometimes desirable to have ordered list, for instance to have the
list of edges incident to a vertex in clockwise or counterclockwise
order.

Some algorithms also require the list of edges opposite to a vertex,
which is called its ring.
  </para>

  <section>
    <title>Edge-based Data Structures</title>
    <para>
    FIXME: introduction
    FIXME: Euler-PoincarÃ© formula  V - E + F = G
      ==> V =~ 0.5 F  E =~ 1.5 F
    </para>

    <section>
      <title>Winged-Edge</title>
    <para>
This data structure had been introduced in 1975 by Bruce G. Baumgart in:
<ulink url="http://www.baumgart.org/winged-edge/winged-edge.html">Use of
Polyhedra in Computer Vision</ulink>.
    </para>

    <para>
An edge contains four pointers to adjoining edges, two pointers to
vertices and two pointers to triangles.  Those pointers are ordered so
that those elements are oriented.  For instance one can decide that an
edge is oriented from its first vertex to the second one, the first face
lies to the left of this segment, and the second one to its right.  Edge
pointers need also to be ordered, for instance
<structfield>cw1</structfield> (clockwise on face 1),
<structfield>ccw1</structfield> (counterclockwise on face 1),
<structfield>cw2</structfield> (clockwise on face 2) and
<structfield>ccw2</structfield> (counterclockwise on face 2).
 <programlisting>
          /         \
         /cw1    ccw1\
        /             \
       /      T1       \
   V1 +-----------------+ V2
       \      T2       /        
        \             /        
         \ccw2    cw2/        
          \         /        
 </programlisting>
With these adjacency relations, we can traverse edges of a face in
clockwise or counterclockwise order, and also traverse edges incident to
a vertex in clockwise or counterclockwise order.
    </para>

    <para>
Triangles and vertices contain a pointer to an incident edge.  So the
total memory cost to store adjacency relations is 13.5F pointers.
    </para>

    <para>
On triangular meshes, we can remove two of the four pointers to edges because
<code>ccw1=cw1(cw1)</code> and idem for <structfield>ccw2</structfield>.
The total memory cost is then reduced to 10.5F pointers.
    </para>
    </section>
<!-- Here E = 3 F because these are half edges -->
    <section>
      <title>Half-Edge</title>
    <para>
This data structure was proposed by Chuck Eastman in 1982.
An edge contains a pointer to the symmetric edge, a pointer to its start
vertex, two pointers to adjoining edges, and a pointer to a triangle.
There are two different half-edge structures, adjoined edges can either
be linked to the same vertex or the same face.
<programlisting>
          /         \                      /         \
         /cw      ccw\                    /cw      ccw\
        /             \                  /             \
       /  T1           \                /      T1       \
   V1 +-------+ +-------+ V2        V1 +-----------------+
       \           T2  /               +-----------------+ V2
        \             /                 \      T2       /     
         \ccw      cw/                   \             /      
          \         /                     \ccw      cw/       
                                           \         /        
          Vertex-edge                       Face-edge
</programlisting>
    </para>

    <para>
Triangles and vertices contain a pointer to an incident edge.
The total memory cost is then also 13.5F pointers.
    </para>

    <para>
As with winged edges, memory requirements can be lowered on triangular
mashes by considering only one adjoining edge instead of two.  With
vertex-edge half-edge structure, <code>ccw=cw(cw(sym))</code> and with
triangle-edge half-edge structure, <code>ccw=cw(cw)</code>.  So this
operation may be tricky with vertex-edge if there are mesh boundaries.
    </para>
    </section>
  </section>

  <section>
    <title>Triangle-based Data Structures</title>
    <para>
We describe here the data structure implemented by Jonathan Richard
Shewchuk in
<ulink url="http://www.cs.cmu.edu/~quake/triangle.html">Triangle</ulink>
Each triangle contains three pointers to vertices and three pointers to
adjoining triangles.  An edge is represented by a triangle and the local
number (between 0 and 2) of this edge in the triangle.  This local
number is called <emphasis>orientation</emphasis> by Jonathan Richard
Shewchuk, and an edge is an <emphasis>oriented triangle</emphasis>.  In
C, pointers to complex structures are aligned to four-byte boundaries.
The orientation of an edge can then be encoded in the pointer itself, by
shifting this pointer to the number of bytes corresponding to its
orientation.  For instance a pointer to the memory address
<code>0x24345471</code> represents the second edge (with an orientation
of 1) of the triangle found at <code>0x24345470</code>.
The total memory cost required to represent adjacency relations is 7.5F.
    </para>

    <para>
We can see that this data structure is very space-efficient to represent
adjacency relations.  In practice we need more data (vertex coordinates,
attributes, etc.) so the gain is not that important.
    </para>
  </section>
  </chapter>

  <chapter>
    <title>Amibe Data Structures</title>
  <para>
We implemented the data structure of Jonathan Richard Shewchuk in Java.
Unfortunately we could not use the same trick about data alignment, so
orientation needs to be encoded.  We need 6 bits per triangle to encode
orientation of adjoining edges in a triangle, so this overhead is pretty
low.

Consider the &OTRI; &ot; below, it belongs to the &TRI; &t; and has a null
<structfield>localNumber</structfield>.
<programlisting>
                        V2
     V5 _________________,________________, V3
        \    &lt;----      / \     &lt;----     /
         \     0     _ /   \      1    _ /
          \\  t0     ///  /\\\   t1    //
           \\1     2///1   0\\\2     0//   t.vertex = { V0, V1, V2 }
            \V     //V   t   \\V     //   t0.vertex = { V2, V1, V3 }
             \     /           \     /    t1.vertex = { V5, V0, V2 }
              \   /      2      \   /     t2.vertex = { V0, V4, V1 }
               \ /     ----&gt;     \ /
             V0 +-----------------+ V1
                 \     &lt;----     /
                  \      1    _ /
                   \\   t2    //
                    \\2     0//
</programlisting>
The following methods can be applied to &ot;:
<programlisting>
   ot.nextOTri();        // Moves (t,0) to (t,1)
   ot.prevOTri();        // Moves (t,0) to (t,2)
   ot.symOTri();         // Moves (t,0) to (t0,2)
   ot.nextOTriOrigin();  // Moves (t,0) to (t2,1)
   ot.prevOTriOrigin();  // Moves (t,0) to (t0,0)
   ot.nextOTriDest();    // Moves (t,0) to (t0,1)
   ot.prevOTriDest();    // Moves (t,0) to (t1,0)
   ot.nextOTriApex();    // Moves (t,0) to (t1,1)
   ot.prevOTriApex();    // Moves (t,0) to (t2,0)
</programlisting>
  </para>

  <para>
It is important to realize that data are stored on triangles, but most
algorithms are edge-based.  Thus &OTRI; is a handle to an edge, which
can be updated when mesh is traversed.  But there is one drawback which
will be exposed later: there is no edge object and it is thus not easy
to work with set of edges.
  </para>

  <section id="pkg-ds">
    <title>Package <classname>org.jcae.mesh.amibe.ds</classname></title>

    <para>
<table border="1">
<title>Class summary of the package <classname>org.jcae.mesh.amibe.ds</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><link linkend="cls-Triangle">&TRI;</link></entry>
  <entry>A triangular element of the mesh.</entry>
</row>
<row>
<entry><link linkend="cls-OTriangle">&OTRI;</link></entry>
  <entry>A handle to abstract edge instances.</entry>
</row>
<row>
<entry><link linkend="cls-OTriangle2D"><classname>OTriangle2D</classname></link></entry>
  <entry>A handle to abstract edge objects for initial 2D mesh.</entry>
</row>
<row>
<entry><link linkend="cls-NotOrientedEdge"><classname>NotOrientedEdge</classname></link></entry>
  <entry>Unique edges, without considering their orientation.</entry>
</row>
<row>
<entry><link linkend="cls-Vertex"><classname>Vertex</classname></link></entry>
  <entry>Vertex of a mesh.</entry>
</row>
<row>
<entry><link linkend="cls-Mesh"><classname>Mesh</classname></link></entry>
  <entry>Mesh data structure.</entry>
</row>
<row>
<entry><classname>MFace3D</classname></entry>
  <entry>(Obsolete) 3D triangle.</entry>
</row>
<row>
<entry><classname>MGroup3D</classname></entry>
  <entry>(Obsolete) Group of triangles in the 3D mesh.</entry>
</row>
<row>
<entry><classname>MMesh3D</classname></entry>
  <entry>(Obsolete) 3D discretization of the whole shape.</entry>
</row>
<row>
<entry><classname>MNode3D</classname></entry>
  <entry>(Obsolete) 3D node.</entry>
</row>
</tbody>
</tgroup>
</table>
    </para>

  <section id="cls-Triangle">
    <title>&TRI;</title>

    <para>
This is the main class.  Its initial implementation followed the one
presented by Jonathan Richard Shewchuk in
<ulink url="http://www.cs.cmu.edu/~quake/triangle.html">Triangle</ulink>:
A &TRI; instance contains references to its three vertices
<programlisting>
        public Vertex [] vertex = new Vertex[3];
        private Object [] adj = new Object[3];
        private int groupId = -1;
</programlisting>
A &TRI; contains three references to its vertices, and three references
to adjacent triangles.  The <structfield>adj</structfield> instance
variable is of type <classname>Object</classname> instead of &TRI; in
order to handle non-manifold objects; each element then contains a list
of triangles.
The <structfield>groupId</structfield> instance variable contains the
identifier of a shell.
    </para>

    <para>
By convention the local number of an edge is the index of its opposite
vertex, thus <code>adj|0]</code> is the triangle adjacent to the edge
opposite of vertex 0, etc.
<programlisting>
                       V2
       _________________,_________________
       \               / \               /
        \             /   \             /
         \   adj[1]  //  /\\  adj[0]   /
          \         //1   0\\         /   t.vertex = { V0, V1, V2 }
           \       /V   t   \\       /
            \     /           \     /
             \   /      2      \   /
              \ /     ----&gt;     \ /
            V0 +-----------------+ V1
                \               /
                 \   adj[2]    /
                  \           /
                   \         /
</programlisting>
    </para>

    <para>
But we also need to know the local number of adjacent edges in their
respective triangles.  Jonathan Richard Shewchuk used word-alignment to
store this information without additional space by shifting pointers to
a number of bytes equal to the local number of edges.  This very
efficient trick can not be performed with Java, and the three numbers
are packed into a single byte instead.  As attributes on edges are also
needed, all edge data are packed into a single
<structfield>adjPos</structfield> integer instance variable.
<programlisting>
        public int adjPos = 0;
</programlisting>
Byte 0 represents the local number of adjacent edges in their respective
triangles:
<itemizedlist spacing="compact">
  <listitem><simpara>bits 0-1: <code>adj[0]</code></simpara></listitem>
  <listitem><simpara>bits 2-3: <code>adj[1]</code></simpara></listitem>
  <listitem><simpara>bits 4-5: <code>adj[2]</code></simpara></listitem>
</itemizedlist>
Bytes 1, 2 and 3 carry up attributes for edges 0, 1 and 2.
These attributes are bitfields, so up to 8 attributes can be defined on
edges.  See &OTRI; for the list of attributes currently defined.
    </para>

    <para>
Typically a &TRI; is created by calling the constructor with its three
vertices, and adjacency relations are set by
<methodname>OTriangle.bind</methodname>.  If there are several common vertices, like
when splitting an edge and thus its two adjacent triangles,
<methodname>Triangle.clone</methodname> can save some work, it creates a new
triangle with the same vertices and adjacency relations.
As described below, a <classname>Mesh</classname> instance contains the
list of its triangles.  When a triangle is created, it needs to be added
to its underlying mesh; this is performed by calling the following
method:
<programlisting>
        public void addToMesh()
</programlisting>
    </para>

    <para>
Algorithms do often need to compute lists of triangles.  In order to
avoid allocation of these lists, a singly linked list is provided by
this class.  It uses class variables, so only one list can be active at
any time.  Here is an example:
<programlisting>
     //  Begin a new list
     Triangle.listLock();
     ...
     //  In a loop, add triangles to this list.
       tri.listCollect();
     //  Check whether a triangle is contained in this list.
     //  This is very fast because it tests if its link pointer
     //  is <constant>null</constant> or not.
       if (tri.isListed()) {
          ...
       }
     //  Loop over collected triangles.
     for (Iterator it = Triangle.getTriangleListIterator(); it.hasNext(); )
     {
       Triangle t = (Triangle) it.next();
       ...
     }
     //  When finished, remove all links between triangles
     Triangle.listRelease();
</programlisting>
   
New elements are added at the end of the list so that
<methodname>listCollect</methodname> can be called while
<methodname>getTriangleListIterator</methodname> is in action.
    </para>
  </section>

  <section id="cls-OTriangle">
    <title>&OTRI;</title>

    <para>
An &OTRI; instance is a handle on an half-edge.
Its instance variables are:
<programlisting>
        Triangle tri;
        int localNumber;
        int attributes;
</programlisting>
Once it is created, its members are updated when traversing mesh.
Symmetric edges are retrieved through <structfield>tri.adj</structfield>
and <structfield>tri.adjPos</structfield>.
    </para>
   
    <para>
There are accessors for the first two instance variables:
<programlisting>
        public final Triangle getTri()
        public final int getLocalNumber()
</programlisting>
These variables cannot be set directly, but
<programlisting>
        public final void bind(Triangle t, int l)
</programlisting>
does the same thing.  The reason why there are no <methodname>setTri</methodname>
and <methodname>setLocalNumber</methodname> methods is that <methodname>setTri</methodname>
would almost always be followed by a call to <methodname>pullAttributes</methodname>,
thus <methodname>bind</methodname> is a shortcut for these two calls.
    </para>
   
    <para>
The main goal of this class is to ease mesh traversal.
Consider the &ot; &OTRI; with a null <structfield>localNumber</structfield>
of &TRI; &t; below:
<programlisting>
                          V2
       V5 _________________,________________, V3
          \    &lt;----      / \     &lt;----     /
           \     0     _ /   \      1    _ /
            \\  t0     ///  /\\\   t1    //
             \\1     2///1   0\\\2     0//   t.vertex = { V0, V1, V2 }
              \V     //V   t   \\V     //   t0.vertex = { V2, V1, V3 }
               \     /           \     /    t1.vertex = { V5, V0, V2 }
                \   /      2      \   /     t2.vertex = { V0, V4, V1 }
                 \ /     ----&gt;     \ /
               V0 +-----------------+ V1
                   \     &lt;----     /
                    \      1    _ /
                     \\   t2    //
                      \\2     0//
</programlisting>
The following methods can be applied to &ot;:
<programlisting>
      ot.nextOTri();        // Moves (t,0) to (t,1)
      ot.prevOTri();        // Moves (t,0) to (t,2)
      ot.symOTri();         // Moves (t,0) to (t0,2)
      ot.nextOTriOrigin();  // Moves (t,0) to (t2,1)
      ot.prevOTriOrigin();  // Moves (t,0) to (t0,0)
      ot.nextOTriDest();    // Moves (t,0) to (t0,1)
      ot.prevOTriDest();    // Moves (t,0) to (t1,0)
      ot.nextOTriApex();    // Moves (t,0) to (t1,1)
      ot.prevOTriApex();    // Moves (t,0) to (t2,0)
</programlisting>
  
An &OTRI; instance can also be cloned into another already allocated
object.
<programlisting>
      OTriangle.copyOTri(src, dest);        // Set dest to (t,0)
      OTriangle.nextOTri(src, dest);        // Set dest to (t,1)
      OTriangle.prevOTri(src, dest);        // Set dest to (t,2)
      OTriangle.symOTri(src, dest);         // Set dest to (t0,2)
      OTriangle.nextOTriOrigin(src, dest);  // Set dest to (t2,1)
      OTriangle.prevOTriOrigin(src, dest);  // Set dest to (t0,0)
      OTriangle.nextOTriDest(src, dest);    // Set dest to (t0,1)
      OTriangle.prevOTriDest(src, dest);    // Set dest to (t1,0)
      OTriangle.nextOTriApex(src, dest);    // Set dest to (t1,1)
      OTriangle.prevOTriApex(src, dest);    // Set dest to (t2,0)
</programlisting>
All these methods are cheap, because structures are not copied, only
references are modified.
    </para>
   
    <para>
When an &OTRI; is traversing the mesh, its reference is not modified,
but its instance variables are updated.  In order to prevent object
allocations, we try to reuse &OTRI; objects as much as we can.
    </para>
   
    <para>
There are accessors to vertices:
<programlisting>
      ot.origin();          // Returns start point, V0 in example above
      ot.destination();     // Returns destibation point, V1 in example above
      ot.apex();            // Returns apex point, V2 in example above
</programlisting>
Vertices can also be modified:
<programlisting>
      ot.setOrigin(v);      // Replaces current origin by Vertex v
      ot.setDestination(v); // Replaces current destination by Vertex v
      ot.setApex(v);        // Replaces current apex by Vertex v
</programlisting>
These three methods modify vertices for the underlying &TRI; instance.
    </para>

    <para>
Attributes can contain these predefined values (several attributes can
be set simultaneously with the bitwise <code>|</code> operator):

<table border="1">
<title><classname>OTriangle</classname> Attributes</title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><constant>BOUNDARY</constant></entry>
  <entry>Edges on a boundary mesh</entry>
</row>
<row>
  <entry><constant>OUTER</constant></entry>
  <entry>Edges exterior to the mesh</entry>
</row>
<row>
  <entry><constant>SWAPPED</constant></entry>
  <entry>Set after swapping an edge, so that it is not swapped again</entry>
</row>
<row>
  <entry><constant>MARKED</constant></entry>
  <entry>Tag an edge so that it is processed only once</entry>
</row>
<row>
  <entry><constant>QUAD</constant></entry>
  <entry>This edge is the invisible boundary of a quadrangle</entry>
</row>
<row>
  <entry><constant>NONMANIFOLD</constant></entry>
  <entry>Non-manifold edge</entry>
</row>
</tbody>
</tgroup>
</table>

The last two attributes are not fully supported and may be deprecated soon
<remark>TODO: When the MARKED attribute is used to flag triangles, it may be
   replaced by a linked list of Triangle instances.</remark>
    </para>

    <para>
The methods to manipulate attributes are:
<variablelist spacing="compact">
  <varlistentry>
    <term><code>hasAttributes(int attr)</code></term>
      <listitem><simpara>Returns &true; if all specified attributes in
      <varname>attr</varname> are set, &false;
      otherwise.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>setAttributes(int attr)</code></term>
      <listitem><simpara>Sets these attributes</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>clearAttributes(int attr)</code></term>
      <listitem><simpara>Clears the specified attributes</simpara></listitem>
  </varlistentry>
</variablelist>
These three methods modify attributes for both &OTRI;
and the underlying &TRI; instances.
But sometimes, attributes need to be synchronized manually, so the
following two functions are provided:
<variablelist spacing="compact">
  <varlistentry>
    <term><code>pullAttributes</code></term>
      <listitem><simpara>Synchronizes attributes from
      &TRI;</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>pushAttributes</code></term>
      <listitem><simpara>Synchronizes &TRI; attributes
      from these ones</simpara></listitem>
  </varlistentry>
</variablelist>
    </para>

    <para>
Adjacency relations are mostly modified by the
<methodname>glue(OTriangle that)</methodname> method, which glues two half-edges together.

<remark>TODO: other methods like <methodname>Triangle.setAdj</methodname> and
   <methodname>OTriangle.setAdj</methodname> could certainly be removed.</remark>
    </para>

    <para>
Some algorithms are provided to modify a mesh.  There is no
preliminarty check to make sure that these algorithms do not modify
topology, so the caller needs to perform the necessary checks.
<programlisting>
        public final void swap()

                    d                    d
                    .                    .
                   /|\                  / \
                  / | \                /   \   
                 /  |  \              /     \
              a +   |   + n  ---&gt;  a +-------+ n
                 \  |  /              \     /
                  \ | /                \   /
                   \|/                  \ /
                    '                    '
                    o                    o
</programlisting>
This routine swaps an edge <code>(&o;&d;)</code> to <code>(&n;&a;)</code>,
updates adjacency relations and backward links between vertices and
triangles.  Current &OTRI; instance is transformed from
<code>(&o;&d;&a;)</code> to <code>(&o;&n;&a;)</code> and not
<code>(&n;&a;&o;)</code>, because this helps turning around &o;, eg. at
the end of <methodname>OTriangle2D.split3</methodname>.
    </para>

    <para>
<programlisting>
        public final void contract(Vertex n)

               V1                       V1
      V3+-------+-------+ V4   V3 +------+------+ V4
         \ t3  / \ t4  /           \  t3 | t4  / 
          \   /   \   /              \   |   /
           \ / t1  \ /                 \ | /  
          o +-------+ d   ------>      n +
           / \ t2  / \                 / | \
          /   \   /   \              /   |   \
         / t5  \ / t6  \           /  t5 | t6  \
        +-------+-------+         +------+------+
      V5        V2       V6     V5       V2      V6
</programlisting>
Contract an edge.  Two triangles are removed, and all adjacent
triangles are updated to replace &o; and &d; vertices by &n;.
The following method
<programlisting>
        public final boolean canContract(Vertex n)
</programlisting>
must be called before <methodname>contract(Vertex n)</methodname> to check that this
contraction is valid.
    </para>

    <para>
<programlisting>
        public final void split(Vertex n)

             V1                       V1        
              +                       /|\
             / \                    /  |  \        
            /   \                 / t1 | t3 \       
           / t1  \              /      |      \      
        o +-------+ d  --->  o +-------+-------+ d   
           \ t2  /              \     n|      /      
            \   /                 \ t2 | t4 /       
             \ /                    \  |  /        
              +                       \|/
             V2                       V2
</programlisting>
This is the opposite of contract.
    </para>
  </section>

  <section id="cls-OTriangle2D">
    <title><classname>OTriangle2D</classname></title>

    <para>
This class inherits from &OTRI; and is designed to perform the initial
2D triangulation.  In particular, boundary edges have not yet been
rebuilt, so we cannot check whether the <constant>OTriangle.OUTER</constant>
attribute is set, but need to test if vertices are equal to the infinite
point &VOUTER; instead.
    </para>
  </section>

  <section id="cls-NotOrientedEdge">
    <title><classname>NotOrientedEdge</classname></title>

    <para>
This class also inherits from &OTRI;, and is used in 3D algorithms
when an half-edge and its symmetric needs to be considered as eauql.
    </para>
  </section>

  <section id="cls-Vertex">
    <title><classname>Vertex</classname></title>

    <para>
Its instance variables are:
<variablelist spacing="compact">
  <varlistentry>
    <term><code>public double [] param = null;</code></term>
      <listitem><simpara>array containing either 2D parameters or 3D
      coordinates, which is why it is not allocated.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private Object link;</code></term>
      <listitem><simpara>In the general case, this is a reference to a
      &TRI; instance containing this vertex.  For non-manifold vertices, it
      is a reference to a list of &TRI; instances.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private Metric2D m2 = null;</code></term>
      <listitem><simpara>metrics computed at this vertex</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private int ref1d = 0;</code></term>
      <listitem><simpara>identifier for nodes on boundary edges</simpara></listitem>
  </varlistentry>
</variablelist>

<remark>TODO: it is certainly a good idea to move 2D specific methods into a
        new VertexZD class.</remark>
<remark>TODO: the <classname>Mesh</classname> class contains the list of
        triangles, but not the list of vertices; it needs to be computed
        when needed.  A singly linked list may be added, like the one in
        &TRI; class, to ease traversal of all vertices.  Or
        alternatively a doubly-linked list may be used to always contain
        the list of vertices.</remark>
    </para>

    <para>
There is a special vertex, &VOUTER;, which represents a vertex at
infinite.  This vertex is used to create exterior triangles.
    </para>
  </section>

  <section id="cls-Mesh">
    <title><classname>Mesh</classname></title>

    <para>
Its instance variables are:
<variablelist spacing="compact">
  <varlistentry>
    <term><code>private int type = MESH_2D;</code></term>
      <listitem><simpara>Mest type</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private ArrayList triangleList = new ArrayList();</code></term>
      <listitem><simpara>Triangle list</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private CADFace face</code></term>
      <listitem><simpara>Topological face on which mesh is applied</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private CADGeomSurface surface;</code></term>
      <listitem><simpara>The geometrical surface describing the topological
      face, stored for efficiency reason</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private double epsilon = 1.0;</code></term>
      <listitem><simpara>Minimal topological edge length</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private boolean accumulateEpsilon = false;</code></term>
      <listitem><simpara>Switch to ignore tiny edges</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>private Stack compGeomStack = new Stack();</code></term>
      <listitem><simpara>Stack of methods to compute geometrical
      values</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public QuadTree quadtree = null;</code></term>
      <listitem><simpara>Structure to fasten search of nearest
      vertices.</simpara></listitem>
  </varlistentry>
</variablelist>
   <remark>TODO: Many variables were introduced for 2D meshing, and do
           not make sense for 3D meshes.  Define a Mesh2D subclass to
           handle 2D meshing specifically.</remark>
   <remark>TODO: Add support for groups in this class.  It is currently
           implemented in &TRI; class only, and adding support here would
           ease some methods.</remark>
    </para>
  </section>

  <section>
    <title>Others</title>

    <para>
 The following classes had been implemented when 3D meshes had their own
 classes, and are deprecated now.  For this reason, they are not detailed
 here:
 <itemizedlist>
   <listitem><simpara>MMesh3D</simpara></listitem>
   <listitem><simpara>MGroup3D</simpara></listitem>
   <listitem><simpara>MFace3D</simpara></listitem>
   <listitem><simpara>MNode3D</simpara></listitem>
 </itemizedlist>
    </para>
  </section>

  <section id="pkg-tools">
    <title>Package <classname>org.jcae.mesh.amibe.ds.tools</classname></title>

    <para>
These classes were implemented when our data structure was only designed
to mesh a single parametrized surface.  We then needed two different sets
of metrics: one for the 2D Euclidian space (this is needed for the initial
triangulation of boundary nodes, see
<link linkend="cls-BasicMesh"><classname>BasicMesh</classname></link>),
and another one to take surface geometrical properties into account.
    </para>

    <para>
They implement the <classname>Calculus</classname> interface, which
defines the following methods:
<variablelist spacing="compact">
  <varlistentry>
    <term><code>public double length(OTriangle ot)</code></term>
      <listitem><simpara>Returns the length of an edge.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public double distance(Vertex start, Vertex end)</code></term>
      <listitem><simpara>Returns the distance between
        <replaceable>start</replaceable> and
        <replaceable>end</replaceable> points.  This distance is computed
        by using metrics of both endpoints.
      </simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public double distance(Vertex start, Vertex end, Vertex vm)</code></term>
      <listitem><simpara>Computes the distance between
        <replaceable>start</replaceable> and
        <replaceable>end</replaceable> points, by using the metrics
        defined at point <replaceable>vm</replaceable>.
      </simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public double radius2d(Vertex vm)</code></term>
      <listitem><simpara>Returns the radius of a 2D circle centered at
        <replaceable>vm</replaceable> so that all points within this
        circle belong to the unit ball of <replaceable>vm</replaceable>
        is in the 3D space.  This method is used in
        <methodname>QuadTree.getNearestVertex</methodname> to determine when
        quadtrees do not have to be considered because they can not
        contain close enough points.
      </simpara></listitem>
  </varlistentry>
</variablelist>

<table border="1">
<title>Class summary of the package <classname>org.jcae.mesh.amibe.ds.tools</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
<entry><classname>Calculus2D</classname></entry>
  <entry>Distance computations in 2D Euclidian space.</entry>
</row>
<row>
  <entry><classname>Calculus3D</classname></entry>
  <entry>Distance computations in 2D parameter space by using 3D
  metrics.</entry>
</row>
</tbody>
</tgroup>
</table>
<remark>TODO: Calculus3D should be renamed, and a new class be created to handle
Vertex in 3D space.</remark>
    </para>
  </section>
  </section>

  <section id="pkg-metrics">
    <title>Package <classname>org.jcae.mesh.amibe.metrics</classname></title>

    <para>
<table border="1">
<title>Class summary of the package <classname>org.jcae.mesh.amibe.metrics</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><link linkend="cls-Matrix2D"><classname>Matrix2D</classname></link></entry>
  <entry>General 2D matrix.</entry>
</row>
<row>
  <entry><link linkend="cls-Matrix3D"><classname>Matrix3D</classname></link></entry>
  <entry>General 3D matrix.</entry>
</row>
<row>
  <entry><link linkend="cls-Metric2D"><classname>Metric2D</classname></link></entry>
  <entry>Metrics on tangent plane.</entry>
</row>
<row>
  <entry><link linkend="cls-Metric3D"><classname>Metric3D</classname></link></entry>
  <entry>3D metrics computed on a CAD surface.</entry>
</row>
</tbody>
</tgroup>
</table>
<remark>TODO: this package should be reorganized and surely merged with
        org.jcae.mesh.amibe.ds.tools</remark>
      </para>

    <section id="cls-Matrix2D">
      <title><classname>Matrix2D</classname></title>
      <para>
This class provides basic operations for general 2x2 matrices:
scale, determinant and inverse.
It also provides a method to compute the intersection of two
2D metrics, which is used by
<link linkend="cls-Metric2D"><classname>Metric2D</classname></link>.
<remark>TODO: This class should certainly be merged with Metric2D.</remark>
      </para>
    </section>

    <section id="cls-Matrix3D">
      <title><classname>Matrix3D</classname></title>
      <para>
This class provides basic operations for general 3x3 matrices:
transposition, scale and multiplication by other matrices and vectors.
It also provides static methods to compute inner and outer products, and
vector norm.
<remark>TODO: prodSca() and prodVect3D() should be renamed into inner()
        and outer() respectively in Matrix3D.</remark>
      </para>
    </section>

    <section id="cls-Metric2D">
      <title><classname>Metric2D</classname></title>
      <para>
This class provides metrics on the tangent plane.
A <link linkend="cls-Metric3D"><classname>Metric3D</classname></link>
is computed and projected onto the tangent plane.  This metric is then
attached to the vertex at which it is computed, and is used to compute
distance to other vertices in <classname>Calculus3D</classname>.
It can be shown that vertices at a distance <varname>D</varname> of a
point lies on an ellipsis centered at <varname>P</varname>.
      </para>

      <para>
If multiple constraints are combined, ellipsis are intersected so that
the resulting metrics fulfill all requirements.  There are several ways
to perform this intersection, here is how it is done in
<code>Matrix2D.intersection</code>.
If <varname>A</varname> and <varname>B</varname> are 2D metrics, there
exists a matrix <varname>P</varname> such that <code>A=tP d(a1,a2)
P</code> and <code>B=tP d(b1,b2) P</code>, where <code>d(x,y)</code> is
the diagonal matrix of coefficients <varname>x</varname> and
<varname>y</varname>.
Then the metric <code>C=tP d(max(a1,b1),max(a2,b2)) P</code>
defines an ellipsis which is interior to both ellipsis.
      </para>
    </section>

    <section id="cls-Metric3D">
      <title><classname>Metric3D</classname></title>
      <para>
3D metrics computed on a CAD surface.  This class provides 3D metrics at a
point to have a unit mesh with respect to edge length and deflection
criteria.
      </para>

      <para>
A metric <varname>M</varname> is a symmetric positive matrix.  It
defines a dot product <code>&lt;X, Y> = tX M Y</code>.  If metrics are
constant, the length of the <code>[PQ]</code> segment in this metrics is
<code>l(M,P,Q)=sqrt(t(PQ) M (PQ))</code>.
A good presentation of meshes governed by metrics can be found in
<ulink url="ftp://ftp.inria.fr/INRIA/publication/publi-pdf/RR/RR-2928.pdf">Maillage
de surfaces paramÃ©triques</ulink> (in French), by Houman Borouchaki and Paul
Louis George.
      </para>

      <para>
The metrics associated with an edge length criterion is the 3x3 matrix
<code>M=Id/(h*h)</code>, where <varname>h</varname> is the target size.
Indeed the relation above clearly shows that <code>l(M,P,Q)=1</code> if
and only if the Euclidian distance between <varname>P</varname> and
<varname>Q</varname> is <varname>h</varname>.  Such a metric is computed
by the <methodname>iso</methodname> method.
      </para>

      <para>
An isotropic metric governed by a given <varname>defl</varname>
geometric error is <code>M=Id*(Cm*Cm)/(alpha*alpha)</code>, where
<varname>Cm</varname> is the largest curvature and
<code>alpha=2*sqrt(defl*(2-defl))</code>.  Of course this geometric
error can be guaranteed onlyelocally, it becomes can be larger if
<varname>defl</varname> is not small enough.  An anisotropic metric can
also be computed along principal curvature directions, see the technical
report above or these sources to find the exact computations.
      </para>

      <para>
Some applications require an absolute geometric error.  A first order
approximation is obtained by replacing <varname>defl</varname> by
<code>defl*Cm</code> in the previous metrics.
      </para>

      <para>
When meshing parametrized surfaces, we need the 2D metric induced
by these 3D metrics to the tangent plane.  This is performed by
the <methodname>restrict2D</methodname> method.
      </para>
    </section>
  </section>

  <section id="pkg-util">
    <title><classname>org.jcae.mesh.amibe.util</classname></title>

    <para>
<table border="1">
<title>Interface summary of the package <classname>org.jcae.mesh.amibe.util</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><link linkend="cls-OctreeProcedure"><classname>OctreeProcedure</classname></link></entry>
  <entry>Procedure to apply on all octree elements.</entry>
</row>
<row>
  <entry><link linkend="cls-QuadTreeProcedure"><classname>QuadTreeProcedure</classname></link></entry>
  <entry>Procedure to apply on all quadtree elements.</entry>
</row>
</tbody>
</tgroup>
</table>
    </para>

    <para>
<table border="1">
<title>Class summary of the package <classname>org.jcae.mesh.amibe.util</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><link linkend="cls-LongLong"><classname>LongLong</classname></link></entry>
  <entry><type>long long</type> type for exact geometrical computations.</entry>
</row>
<row>
  <entry><link linkend="cls-Octree"><classname>Octree</classname></link></entry>
  <entry>Octree structure to store 3D vertices.
  </entry>
</row>
<row>
  <entry><classname>OctreeTest</classname></entry>
  <entry>Utility class to write unit tests for the
  <classname>Octree</classname> class.</entry>
</row>
<row>
  <entry><link linkend="cls-PAVLSortedTree"><classname>PAVLSortedTree</classname></link></entry>
  <entry>PAVL binary trees to store quality factors.</entry>
</row>
<row>
  <entry><link linkend="cls-QuadTree"><classname>QuadTree</classname></link></entry>
  <entry>Quadtree structure to store 2D vertices.</entry>
</row>
<row>
  <entry><classname>QuadTreeTest</classname></entry>
  <entry>Utility class to write unit tests for the
  <classname>QuadTree</classname> class.</entry>
</row>
<row>
  <entry><classname>UNVReader</classname></entry>
  <entry>FIXME</entry>
</row>
</tbody>
</tgroup>
</table>
    </para>

  <section id="cls-QuadTreeProcedure">
    <title><interfacename>QuadTreeProcedure</interfacename></title>
    <para>
This interface is used as an argument of the
<methodname>QuadTree.walk</methodname> method.  It defines a single method:
<programlisting>
    public action(Object o, int s, int i, int j)
</programlisting>
Its arguments are defined as follows:
<variablelist spacing="compact" termlength="3">
  <varlistentry>
    <term><varname>o</varname></term>
    <listitem><simpara>A reference to a <classname>QuadTree.Cell</classname> instance.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>s</varname></term>
    <listitem><simpara>Cell size.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>i</varname></term>
    <listitem><simpara>First coordinate of the bottom left corner of this cell. </simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>j</varname></term>
    <listitem><simpara>Second coordinate of the bottom left corner of this cell.</simpara></listitem>
  </varlistentry>
</variablelist>
The return value of this method can alter quadtree traversal: if
<constant>-1</constant> is returned, <code>QuadTree.walk</code>
aborts immediately its traversal.  If another non-null value is
returned, children nodes qre skipped.  Otherwise processing continus
normally.
    </para>
  </section>

  <section id="cls-OctreeProcedure">
    <title><interfacename>OctreeProcedure</interfacename></title>
    <para>
This interface is used as an argument of the
<methodname>Octree.walk</methodname> method.  It defines a single method:
<programlisting>
    public action(Object o, int s, int i, int j, int k)
</programlisting>
Its arguments are defined as follows:
<variablelist spacing="compact">
  <varlistentry>
    <term><varname>o</varname></term>
    <listitem><simpara>A reference to a <classname>QuadTree.Cell</classname> instance.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>s</varname></term>
    <listitem><simpara>Cell size.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>i</varname></term>
    <listitem><simpara>First coordinate of the bottom left corner of this cell. </simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>j</varname></term>
    <listitem><simpara>Second coordinate of the bottom left corner of this cell.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>k</varname></term>
    <listitem><simpara>Third coordinate of the bottom left corner of this cell.</simpara></listitem>
  </varlistentry>
</variablelist>
The return value of this method can alter octree traversal: if
<constant>-1</constant> is returned, <code>Octree.walk</code>
aborts immediately its traversal.  If another non-null value is
returned, children nodes qre skipped.  Otherwise processing continus
normally.
    </para>
  </section>

  <section id="cls-QuadTree">
    <title><classname>QuadTree</classname></title>

    <para>
This class implements a quadtree structure to store 2D vertices.  When
adjacent relations have not yet been set, a quadtree is an efficient way
to locate a point among a set of points and triangles.
    </para>

    <para>
Integer coordinates are used for two reasons: a better control on accuracy
of geometrical operations, and simpler operations on vertex location because
cells have power of two side length and bitwise operators can be used
instead of floating point operations: if the cell size is <code>2*s</code>
then a point <code>(i,j)</code> is located in the quadrant
<code>((i &amp; s) == 0 ? 0 : 1) + 2*(((j &amp; s) == 0) ? 0 : 1)</code>.
<table border="1">
<title>Quadrant index</title>
<tgroup cols="3">
<colspec align="right"/>
<colspec colsep="1" rowsep="1" align="center"/>
<colspec colsep="1" rowsep="1" align="center"/>
<tbody>
<row>
  <entry><code>J&lt;>0</code></entry>
  <entry>2</entry>
  <entry>3</entry>
</row>
<row>
  <entry><code>J=0</code></entry>
  <entry>0</entry>
  <entry>1</entry>
</row>
<row>
  <entry> </entry>
  <entry><code>I=0</code></entry>
  <entry><code>I&lt;>0</code></entry>
</row>
</tbody>
</tgroup>
</table>
where <code>I = i &amp; s</code>, <code>J = j &amp; s</code>.
    </para>

    <para>
The downside is that conversion between double and integer coordinates
must be known in advance, which is why constructor needs a bounding box
as argument.
    </para>

    <para>
The inner class <classname>QuadTree.Cell</classname> is defined like
this:
<programlisting>
    protected class Cell
    {
        // Maximal number of vertices which can be stored in a cell.
        protected static final int BUCKETSIZE = 10;
        
        // Number of vertices stored below the current cell.
        protected int nItems = 0;
        
        // References to bound objects.
        protected Object [] subQuad = null;
    }
</programlisting>
A <classname>QuadTree.Cell</classname> instance contains either vertices or four
children nodes (some of them may be <constant>null</constant>).  A cell
can contain at most <constant>QuadTree.Cell.BUCKETSIZE</constant> vertices
(default is 10).  By convention, <structfield>nItems</structfield>  is
positive if the cell contains vertices, and negative if it contains
children nodes.  Its absolute value is always the total number of
vertices located in this cell.
When a cell contains vertices and becomes full, it is splitted: children
nodes are created, vertices are stored there and the
<structfield>subQuad</structfield> instance variable contains references
to these children nodes.  On the contrary, when all vertices are removed
from a cell, it is deleted.  And when all children of a cell are empty,
this cell is removed.
    </para>

    <para>
Quadtree cells are very compact, they do not contain any locational
information.  It is instead passed to the
<methodname>QuadTreeProcedure.action</methodname> method.
This design had been chosen for performance reasons on large meshes, and
in practice it works very well because quadtrees are used for vertex
location, and no neighbourhood information is needed.
    </para>

    <para>
Here is an example to collect inside a list all vertices stored in a
<classname>QuadTree</classname> <varname>q</varname>:
<programlisting>
    class collectAllVerticesProcedure implements QuadTreeProcedure
    {
        protected ArrayList vertexList = new ArrayList();
        public final int action(Object o, int s, int i0, int j0)
        {
            Cell self = (Cell) o;
            if (self.nItems > 0)
            {
                for (int i = 0; i &lt; self.nItems; i++)
                    vertexList.add(self.subQuad[i]);
            }
            return 0;
        }
    };
    collectAllVerticesProcedure cproc = new collectAllVerticesProcedure();
    q.walk(cproc);
    ArrayList vlist = cproc.vertexList;
</programlisting>
    </para>

    <para>
The <code>proc.action</code> method is applied on all cells
recursively in prefix order.  If it
returns <constant>-1</constant>, <code>walk</code> aborts its
processing immediately.  A null return value means that processing can
continue normally, and a non-null return value means that children nodes are
skipped.
    </para>

    <para>
Distances between vertices can be computed either in Euclidian 2D space, or
with a Riemannian metrics.  This is controlled by the
<code>setCompGeom</code> method.  Distances are computed in Euclidian 2D
space when its argument is an instance of
<classname>org.jcae.mesh.amibe.ds.tools.Calculus2D</classname>,
and in Riemannian metrics (see
<classname>org.jcae.mesh.amibe.metrics.Metric2D</classname>) when
it is an instance of
<classname>org.jcae.mesh.amibe.ds.tools.Calculus3D</classname>.
By default, distances are computed in Euclidian 2D space.
<programlisting>
    //  Compute distances in getNearVertex and getNearestVertex
    //  with an Euclidian 2D metric
    q.setCompGeom(new org.jcae.mesh.amibe.ds.tools.Calculus2D());
    ...
    //  ... with a Riemannian 2D metric
    q.setCompGeom(new org.jcae.mesh.amibe.ds.tools.Calculus2D());
</programlisting>
    </para>

    <para>
In Euclidian 2D space, vertices which have a distance to a point
<varname>p</varname> lower than <varname>d</varname> are contained in a
circle centered at <varname>p</varname> with radius
<varname>d</varname>.  With Riemannian metrics, this circle becomes an
ellipsis.  This ellipsis is only determined by local properties of the
surface at point <varname>p</varname>.  If we already found a point
<varname>V1</varname> at a distance <varname>d1</varname>, vertices
which belong to a quadtree cell not intersecting this ellipsis do not
need to be considered.
    </para>

    <para>
Below is an algorithm to find the nearest vertex in the quadtree of a given
point <varname>p</varname>:
<orderedlist numeration="arabic" spacing="compact">
  <listitem><simpara>Initialization: <code>dmin=Double.MAX_VALUE</code>,
    <code>result=null</code></simpara></listitem>
  <listitem><para>Traverse all quadtree cells.
  <orderedlist numeration="loweralpha" spacing="compact">
    <listitem><simpara>If this cell does not intersect the ellipsis
      centered at <varname>p</varname> of vertices at a distance lower
      than <varname>dmin</varname>, then skip this cell and its
      children.</simpara></listitem>
    <listitem><simpara>Otherwise, if this cell contains children nodes, do
      nothing so that processaing continues normally on children
      nodes.</simpara></listitem>
    <listitem><simpara>Otherwise, this cell contains vertices.  For each
      vertex, compute its distance to <varname>p</varname> and update
      <varname>dmin</varname> and <varname>result</varname> if it is
      nearer than the current solution.</simpara></listitem>
  </orderedlist></para></listitem>
</orderedlist>
    </para>

    <para>
The implementation of <code>getNearestVertex</code> has two differences:
<itemizedlist>
  <listitem><para>The starting point is computed by
    <code>getNearVertex</code>.  This means that much more cells are
    skipped.</para></listitem>
  <listitem><para>The ellipsis is replaced by a circle enclosing it, to
    have simpler calculus.  <remark>TODO: Using the real ellipsis could
    be tested though, it should also speed up this
    processing.</remark></para></listitem>
</itemizedlist>
  </para>
  </section>

  <section id="cls-Octree">
    <title><classname>Octree</classname></title>

    <para>
This class implements an octree structure for 3D vertices.
It is very similar to <classname>QuadTree</classname>, it is useful to
find near vertices.  It was needed by
<classname>org.jcae.mesh.amibe.algos3d.Fuse</classname> to fuse near
vertices, but now that 3D meshes are also handled by the
<classname>org.jcae.mesh.amibe.ds.Mesh</classname> class, it became
oobsolete because adjacency relations between vertices are provided by
<classname>org.jcae.mesh.amibe.ds.Mesh</classname>.
Anyway this implementation has not yet been removed and may be useful
again in a near future.
    </para>

    <para>
Integer coordinates are used for two reasons: a better control on accuracy
of geometrical operations, and simpler operations on vertex location because
cells have power of two side length and bitwise operators can be used
instead of floating point operations: if the cell size is <code>2*s</code>
then a point <code>(i,j,k)</code> is located in the octant
<code>(((i &amp; s) == 0 ? 0 : 1) + 2*(((j &amp; s) == 0) ? 0 : 1) + 4*(((k &amp; s) == 0) ? 0 : 1))</code>:
<table border="1">
<title>Octant index</title>
<tgroup cols="6">
<colspec colname="c1" align="right"/>
<colspec colname="c2" colsep="1" rowsep="1" align="center"/>
<colspec colname="c3" colsep="1" rowsep="1" align="center"/>
<colspec colname="ruler" colsep="1" rowsep="1" align="center"/>
<colspec colname="c4" colsep="1" rowsep="1" align="center"/>
<colspec colname="c5" colsep="1" rowsep="1" align="center"/>
<tbody>
<row>
  <entry> </entry>
  <entry namest="c2" nameend="c3" align="center"><code>K=0</code></entry>
  <entry> </entry>
  <entry namest="c4" nameend="c5" align="center"><code>K&lt;>0</code></entry>
</row>
<row>
  <entry><code>J&lt;>0</code></entry>
  <entry>2</entry>
  <entry>3</entry>
  <entry> </entry>
  <entry>6</entry>
  <entry>7</entry>
</row>
<row>
  <entry><code>J=0</code></entry>
  <entry>0</entry>
  <entry>1</entry>
  <entry> </entry>
  <entry>4</entry>
  <entry>5</entry>
</row>
<row>
  <entry> </entry>
  <entry><code>I=0</code></entry>
  <entry><code>I&lt;>0</code></entry>
  <entry> </entry>
  <entry><code>I=0</code></entry>
  <entry><code>I&lt;>0</code></entry>
</row>
</tbody>
</tgroup>
</table>
where <code>I = i &amp; s</code>, <code>J = j &amp; s</code> and
<code>K = k &amp; s</code>.
    </para>

    <para>
The downside is that the conversion between double and integer
coordinates must be known in advance, which is why constructor needs a
bounding box as argument.
    </para>

    <para>
The inner class <classname>Octree.Cell</classname> is defined like
this:
<programlisting>
    protected class Cell
    {
        // Number of vertices stored below the current cell.
        protected int nItems = 0;
        
        // References to bound objects.
        protected Object [] subOctree = null;
    }
</programlisting>
An <classname>Octree.Cell</classname> instance contains either vertices
or eight children nodes (some of them may be <constant>null</constant>).
A cell can contain at most <constant>Octree.BUCKETSIZE</constant>
vertices (default is 10).  By convention,
<structfield>nItems</structfield> is positive if the cell contains
vertices, and negative if it contains children nodes.  Its absolute
value is always the total number of vertices located in this cell.
When a cell contains vertices and becomes full, it is splitted: children
nodes are created, vertices are stored there and the
<structfield>subOctree</structfield> instance variable contains references
to these children nodes.  On the contrary, when all vertices are removed
from a cell, it is deleted.  And when all children of a cell are empty,
this cell is removed.
    </para>

    <para>
Octree cells are very compact, they do not contain any locational
information.  It is instead passed to the
<code>OctreeProcedure.action</code> method.  This design had been chosen
for performance reasons on large meshes, and in practice it works very
well because octrees are used for vertex location, and no neighbourhood
information is needed.
    </para>

    <para>
Here is an example to collect inside a list all vertices stored in a
<classname>Octree</classname> <varname>oct</varname>:
<programlisting>
    class collectAllVerticesProcedure implements OctreeProcedure
    {
        protected ArrayList vertexList = new ArrayList();
        public final int action(Object o, int s, int i0, int j0)
        {
            Cell self = (Cell) o;
            if (self.nItems > 0)
            {
                for (int i = 0; i &lt; self.nItems; i++)
                    nodelist.add(self.subQuad[i]);
            }
            return 0;
        }
    };
    collectAllVerticesProcedure cproc = new collectAllVerticesProcedure();
    oct.walk(cproc);
    ArrayList vlist = cproc.vertexList;
</programlisting>
    </para>

    <para>
The <code>proc.action</code> method is applied on all cells
recursively in prefix order.  If it
returns <constant>-1</constant>, <code>walk</code> aborts its
processing immediately.  A null return value means that processing can
continue normally, and a non-null return value means that children nodes are
skipped.
    </para>

    <para>
Below is an algorithm to find the nearest vertex in the octree of a given
point <varname>p</varname>:
<orderedlist numeration="arabic">
  <listitem><simpara>Initialization: <code>dmin=Double.MAX_VALUE</code>,
    <code>result=null</code></simpara></listitem>
  <listitem><para>Traverse all octree cells.
  <orderedlist numeration="loweralpha">
    <listitem><simpara>If this cell does not intersect the sphere
      centered at <varname>p</varname> of vertices at a distance lower
      than <varname>dmin</varname>, then skip this cell and its
      children.</simpara></listitem>
    <listitem><simpara>Otherwise, if this cell contains children nodes, do
      nothing so that processaing continues normally on children
      nodes.</simpara></listitem>
    <listitem><simpara>Otherwise, this cell contains vertices.  For each
      vertex, compute its distance to <varname>p</varname> and update
      <varname>dmin</varname> and <varname>result</varname> if it is
      nearer than the current solution.</simpara></listitem>
  </orderedlist></para></listitem>
</orderedlist>
    </para>

    <para>
The implementation of <code>getNearestVertex</code> is slightly improved:
the starting point is computed by <code>getNearVertex</code>, so that
much more cells are skipped.
    </para>
  </section>

  <section id="cls-PAVLSortedTree">
    <title><classname>PAVLSortedTree</classname></title>

    <para>
Main ideas come from Ben Pfaff's
<ulink url="http://adtinfo.org/">GNU libavl</ulink>.
An AVL tree is a binary tree for which each node is almost balanced, height
of its left and right children can not differ by more than one.  The initial
P means that each node has a backward link to his parent.  Tests have been
performed to compare this PAVL implementation with a modified one without
those backward links.  There was no noticeable differences, but we kept the
PAVL structure because implementation is simpler.
These trees are used to sort vertices, edges, or triangles according
to their quality factors, and process them in increasing or decreasing
order.  See examples in algorithms from
<link linkend="pkg-algos3d"><classname>org.jcae.mesh.amibe.algos3d</classname></link>.
Each node of the tree contains a key (which is used for sorting, this is
of <type>double</type> value), two references to its left and right
children, a reference to its parent and its balance factor.  A tree
contains a mapping between the objects stored in the tree and tree nodes.
    </para>

    <para>
Here are the most useful methods:
<variablelist spacing="compact">
  <varlistentry>
    <term><code>public void insert(Object o, double value)</code></term>
      <listitem><simpara>Inserts the object <varname>o</varname> into
      the tree, associated to the quality factor
      <varname>value</varname>.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public double remove(Object o)</code></term>
      <listitem><simpara>Removes this object from the tree.  Its old
      quality factor is returned.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public void update(Object o, double value)</code></term>
      <listitem><simpara>Updates the quality factor of the specified
      object to a new <varname>value</varname>.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public Object first()</code></term>
    <term><code>public Object last()</code></term>
      <listitem><simpara>Returns the <classname>Object</classname> with
      the lowest and highest quality factor.</simpara></listitem>
  </varlistentry>
  <varlistentry>
    <term><code>public Object prev()</code></term>
    <term><code>public Object next()</code></term>
      <listitem><simpara>After <code>first</code> or <code>last</code>
      methods are called, these methods return the
      <classname>Object</classname> immediately before or after the
      current one in the tree.</simpara></listitem>
  </varlistentry>
</variablelist>
    </para>

    <para>
Example:
<programlisting>
    PAVLSortedTree tree = new PAVLSortedTree();
    OTriangle ot = new OTriangle();
    // Insert triangle areas into the tree
    for (Iterator itf = mesh.getTriangles().iterator(); itf.hasNext(); )
    {
        Triangle f = (Triangle) itf.next();
        if (f.isOuter())
            continue;
        ot.bind(f);
        tree.insert(f, ot.computeArea());
    }
    // Process triangles according to their area in ascending order
    for (Object o = tree.first(); o != null; o = tree.next())
    {
        Triangle f = (Triangle) o;
        ...
    }
</programlisting>
    </para>

    <para>
<remark>TODO: the current implementation is suboptimal.  This map
        can be avoided by introducing a new class public PAVLNode
        which contains tree cells.
        Update: This has been implemented in PAVLSortedTree2</remark>
<remark>TODO: algos2d aqlgorithms could certainly take advantage of
        these trees.</remark>
    </para>
  </section>

  <section id="cls-LongLong">
    <title><classname>LongLong</classname></title>

    <para>
This class implements a <type>long long</type> type for exact 2D
geometrical computations.  As interpolation of metrics lead to larger
rounding errors, this class is only useful for 2D meshes in natural
Euclidian space.
    </para>
  </section>

  </section>
  </chapter>

  <chapter>
    <title>Algorithms</title>
    <section>
      <title>2D Algorithms</title>

  <para>
  FIXME
  </para>
  </section>

  <section id="pkg-algos2d">
    <title>Package <classname>org.jcae.mesh.amibe.algos2d</classname></title>
  <para>
<table border="1">
<title>Class summary of the package <classname>org.jcae.mesh.amibe.algos2d</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><link linkend="cls-BasicMesh"><classname>BasicMesh</classname></link></entry>
  <entry>Performs an initial Delaunay triangulation.</entry>
</row>
<row>
  <entry><link linkend="cls-CheckDelaunay"><classname>CheckDelaunay</classname></link></entry>
  <entry>Swap edges which are not Delaunay.</entry>
</row>
<row>
  <entry><link linkend="cls-ConstraintNormal3D"><classname>ConstraintNormal3D</classname></link></entry>
  <entry>Swap edges if the normals to its adjacent triangles are too
  different from the normal computed by the CAD engine.</entry>
</row>
<row>
  <entry><link linkend="cls-EnforceAbsDeflection"><classname>EnforceAbsDeflection</classname></link></entry>
  <entry>Split triangles with an absolute deflection greater than
  requirements.</entry>
</row>
<row>
  <entry><link linkend="cls-Insertion"><classname>Insertion</classname></link></entry>
  <entry>Insert nodes to produce a unit mesh.</entry>
</row>
</tbody>
</tgroup>
</table>
  </para>

    <section id="cls-BasicMesh">
      <title><classname>BasicMesh</classname></title>

      <para>
This algorithm is invoked to perform the initial triangulation of
each CAD patch, after the discretization of edges has been performed.
Wires of this patch are processed in turn.  All nodes belonging to
discretization of these edges are projected onto this 2D patch
and collected into a list.  These nodes are boundary nodes, and
all other nodes will be inserted in the interior domain.  A bounding
box enclosing all these nodes in the 2D space is computed, and
a <link linkend="cls-QuadTree"><classname>QuadTree</classname></link>
instance can then be initialized by the <code>Mesh.initQuadTree</code>
method.
      </para>

      <para>
<remark>TODO:
Some checks have been added to remove tiny edges and make sure that
boundary is closed.  But this is a hack, the right solution is
to analyze the overall CAD structure and make sure that edges are well
connected and not too small.  In particular, the tolerance on vertex
location should be used to remove vertices which may be duplicates.
</remark>
      </para>

      <para>
A first triangle is created by iterating over the list of boundary nodes
to find three vertices which are not aligned.  The outer domain is also
triangulated;
<link linkend="cls-Vertex">&VOUTER;</link> is a vertex at infinite, and
three outer triangles are created by joining this vertex to vertices of
the first triangle.  With this trick, there is no need to have special
cases when vertices are inserted outside the convex hull of already
inserted vertices, and triangle location always succeed.  If these outer
triangles did not exist, we would have to triangulate the convex hull of
nodes.
      </para>

      <para>
Boundary nodes are then inserted iteratively.  For the moment, an Euclidian
2D metric is used because a 3D metric will not help on a very rough
triangulation.  The nearest vertex already inserted in the mesh is retrieved
with <code>QuadTree.getNearestVertex</code>.
It has a reference to a triangle containing this vertex.  From this starting
triangle, we search for the <classname>Triangle</classname> instance
containing this boundary node by looking for adjacent triangles into the
right direction.  This <classname>Triangle</classname> instance is
splitted into three triangles (even if the vertex is inserted on an
edge), and edges are swapped if they are not Delaunay.  (This criterion
also applied with our Euclidian 2D metric)
      </para>

      <para>
When all boundary nodes are inserted, an unconstrained Delaunay mesh has
been built.  The list of boundary nodes computed previously gives a list of
boundary edges, which needs to be enforced.  This is performed by
<code>Mesh.forceBoundaryEdge</code>; the segments which
intersect the enforced edge are swapped.  The
<constant>OTriangle.BOUNDARY</constant> attribute is set on these edges
(and on matte edges).
      </para>

      <para>
We know that the <classname>Triangle</classname> instance bound to
&VOUTER; is an outer triangle.  Triangles adjacent through a boundary
edge are interior triangles, and triangles adjacent through non-boundary
edges are also outer triangles.  All triangles of the mesh are visited,
and outer triangles are tagged with the
<constant>OTriangle.OUTER</constant> attribute.  If an inconsistency is
found (for instance a boundary edge seperate two outer triangles),
<code>InitialTriangulationException</code> is
raised.  This means that boundary was invalid, eg. it is not closed
or intersects itself.
<remark>TODO:
This detection of broken boundaries could be improved by taking
advantage of some OpenCascade features, like the detection of
self-intersection and object tolerance.
</remark>
      </para>

      <para>
It is important to note that triangles in holes have their
<constant>OUTER</constant> attribute set, but are not linked to
&VOUTER;.  So this attribute is the only safe way to detect outer
triangles.  As outer triangles are not removed, vertex location can
still be performed as if the domain was convex.  All subsequent 2D
algorithms should consider these points.
      </para>

      <para>
This is very different when remeshing 3D meshes; in such a case,
boundary edges are detected because they have only one incident
face.  An outer triangle is then added by connecting end points to
&VOUTER;, but outer triangles are not connected together.
Mesh domain is not convex, but that does not matter because 3D
algorithms do not require vertex location.
      </para>

      <para>
After this initial triangulation has been performed, it is time to
add interior vertices to fulfill user's requirements.  The Euclidian 2D
metric is replaced by the 2D Riemannian metric
<classname>Metric2D</classname> induced by surface local properties and
user constraints.  But current triangles can cross the whole surface, so
metrics of its vertices may be very different.  There are two problems:
<itemizedlist>
  <listitem><simpara>Length computations are not accurate.</simpara></listitem>
  <listitem><simpara>If the parametrization of the surface has large variations,
      triangles in 3D space may be inverted.</simpara></listitem>
</itemizedlist>
      </para>

      <para>
<remark>TODO:
In order to improve accuracy, FrÃ©dÃ©ric Hecht advised to recursively
split segments when metrics at end points are very different.  This
is implemented in <code>Calculus3D.distance</code> but did not give good
results.  Now that the whole process works much better, this issue could
be investigated again.
</remark>
      </para>

      <para>
About inverted triangles, he also explained that we do not have to
care if large triangles are inverted in 3D, because they will be
fixed naturally when being splitted up.
      </para>

      <para>
<remark>TODO:
The current implementation begins with swapping edges (by calling
{@link OTriangle2D#checkSmallerAndSwap}) if the opposite diagonal
is smaller.  This method did improve some test cases, but is
certainly useless with the current meshing process because it has
been dramatically improved since these tests have been performed.
</remark>
      </para>

      <para>
The following steps are then performed:
<orderedlist numeration="arabic">
   <listitem><simpara>Insert interior nodes (see
      <link linkend="cls-Insertion"><classname>Insertion</classname></link>)
      to have a mesh with target size of 16.</simpara></listitem>
   <listitem><simpara>Check compatibility between triangle normals
      and normals to the surface (see
      <link
      linkend="cls-ConstraintNormal3D"><classname>ConstraintNormal3D</classname></link>).
      If triangle inversion gives better result, edges are
      swapped.</simpara></listitem>
   <listitem><simpara>Insert interior nodes to have a mesh with target
      size of 4.</simpara></listitem>
   <listitem><simpara>Check compatibility between triangle normals
      and normals to the surface.</simpara></listitem>
   <listitem><simpara>Insert interior nodes to have a mesh with target
      size of 1.</simpara></listitem>
   <listitem><simpara>Check compatibility between triangle normals
      and normals to the surface.</simpara></listitem>
</orderedlist>
      </para>
    </section>

    <section id="cls-Insertion">
      <title><classname>Insertion</classname></title>

      <para>
This algorithm inserts nodes to produce a unit mesh.
All edges are first processed; if an edge is longer than sqrt(2),
candidate vertices are added to a bucket to virtually provide unit
length subsegments.
The next step is to take vertices from the bucket in random order.
For each vertex <varname>v</varname>, the closest vertex
<varname>w</varname> already present in the mesh is returned by
<code>org.jcae.mesh.amibe.util.QuadTree.getNearestVertex(Vertex)</code>
If the distance between <varname>v</varname> and <varname>w</varname>
is lower than 1/sqrt(2), <varname>v</varname> is dropped, otherwise it
is inserted into the mesh.  Just after a vertex is inserted, incident
edges are swapped if they are not Delaunay.  The whole process is
repeated until no new vertex is added.
      </para>

      <para>
If all vertices of an edge were inserted at the same time, adjacent
edges may get in trouble because their candidate vertices could be
too near from these points.  In order to avoid this problem, vertices
are processed in a random order so that all edges have a chance to be
splitted.  As we want reproducible meshes, a pseudo-random order is
preferred.
      </para>

      <para>
<remark>TODO:
Triangle centroids are also inserted if they are not too near of
existing vertices.  This was added to try to improve triangle
quality, but is a bad idea.  Bad triangles should instead be sorted
(with <link linkend="cls-PAVLSortedTree">PAVLSortedTree</link>) and
their circumcenter added to the mesh if the overall quality is improved, 
</remark>
      </para>
    </section>

    <section id="cls-CheckDelaunay">
      <title><classname>CheckDelaunay</classname></title>

      <para>
This algorithm swaps edges which are not Delaunay.  In an Euclidian 2D
metrics, there is a unique Delaunay mesh, so edges can be processed in
any order.
<remark>TODO:
But with a Riemannian metrics this is no more true, edges
with the poorest quality should be processed first to improve the
overall quality.  This is not implemented yet, edges are currently not
sorted.
</remark>
      </para>
    </section>

    <section id="cls-ConstraintNormal3D">
      <title><classname>ConstraintNormal3D</classname></title>

      <para>
Swap edges if the normals to its adjacent triangles are too different
from the normal computed by the CAD engine.  Triangles in the 2D
parameter space must not be inverted, otherwise some methods do not
work any more.  But even in this case, if the surface parametrization
has large variations over a triangle, triangles may be inverted in
the 3D space.  The current algorithm is quite naive.  It works well,
so we did not try to find a better alternative.
      </para>

      <para>
For each non-boundary edge, we first check that this edge can be
swapped without inverting triangles in 2D space.  The normal to the
surface at the middle of the edge is computed by the CAD engine.
Inner products between this vector and triangle normals are computed,
the quelity of this edge is the minimum of the two values.  The same
computations are performed on swapped triangles, and if the quality
is improved, this edge is indeed swapped.
      </para>
    </section>

    <section id="cls-EnforceAbsDeflection">
      <title><classname>EnforceAbsDeflection</classname></title>

      <para>
Split triangles with an absolute deflection greater than
requirements.  As explained in
<link linkend="cls-Metric3D">Metric3D</link>, the geometric error
may exceed the desired value if triangles are too far away from local
tangent planes.  This algorithm computes the deflection of triangle
centroids, and if it is larger than the requested value, this
centroid is inserted into the mesh and incident edges are swapped
if they are not Delaunay.
      </para>
    </section>

    </section>

    <section>
      <title>3D Algorithms</title>
  <para>
  FIXME
  </para>
    </section>

  <section id="pkg-algos3d">
    <title>Package <classname>org.jcae.mesh.amibe.algos3d</classname></title>
  <para>
<table border="1">
<title>Class summary of the package <classname>org.jcae.mesh.amibe.algos3d</classname></title>
<tgroup cols="2" colsep="1" rowsep="1">
<tbody>
<row>
  <entry><link linkend="cls-DecimateVertex"><classname>DecimateVertex</classname></link></entry>
  <entry>Decimates a mesh.</entry>
</row>
<row>
  <entry><classname>Fuse</classname></entry>
  <entry>(Obsolete) Fuse near nodes in a MMesh3D instance.</entry>
</row>
<row>
  <entry><link linkend="cls-SmoothNodes3D"><classname>SmoothNodes3D</classname></link></entry>
  <entry>3D node smoothing.</entry>
</row>
<row>
  <entry><link linkend="cls-SplitEdge"><classname>SplitEdge</classname></link></entry>
  <entry>Split long edges.</entry>
</row>
</tbody>
</tgroup>
</table>
  </para>

    <section id="cls-DecimateVertex">
      <title><classname>DecimateVertex</classname></title>

      <para>
Decimates a mesh.  This method is based on Michael Garland's work on
<ulink url="http://graphics.cs.uiuc.edu/~garland/research/quadrics.html">Quadric
Error Metrics</ulink>.
    </para>

    <para>
A plane is fully determined by its normal <varname>N</varname> and the signed
distance <varname>d</varname> of the frame origin to this plane, or in other 
words the equation of this plane is <code>tN V + d = 0</code>.
The squared distance of a point to this plane is
<literallayout>
  D*D = (tN V + d) * (tN V + d)
      = tV (N tN) V + 2d tN V + d*d
      = tV A V + 2 tB V + c
</literallayout>
    </para>

    <para>
The quadric <code>Q=(A,B,c)=(N tN, dN, d*d)</code> is thus naturally
defined.  Addition of these quadrics have a simple form:
<code>Q1(V)+Q2(V)=(Q1+Q2)(V)</code> with
<code>Q1+Q2=(A1+A2, B1+B2, c1+c2)</code>
To compute the squared distance of a point to a set of planes, we can
then compute this quadric for each plane and sum each element of
these quadrics.  
    </para>

    <para>
When an edge <code>(V1,V2)</code> is contracted into <code>V3</code>,
<code>Q1(V3)+Q2(V3)</code> represents the deviation to the set of
planes at <code>V1</code> and <code>V2</code>.  The cost of this
contraction is thus defined as <code>Q1(V3)+Q2(V3)</code>.
We want to minimize this error.  It can be shown that if <code>A</code>
is non singular, the optimal placement is for <code>V3=-inv(A) B</code>.
    </para>

    <para>
The algorithm is straightforward:
<orderedlist spacing="compact">
  <listitem><simpara>Quadrics are computed for all vertices.</simpara></listitem>
  <listitem><simpara>For each edge, compute the optimal placement and its cost.</simpara></listitem>
  <listitem><simpara>Loop on edges: starting with the lowest cost, each edge is
     processed until its cost is greater than the desired tolerance, and costs
     of adjacent edges are updated.</simpara></listitem>
</orderedlist>
    </para>

    <para>
The real implementation is slightly modified:
<orderedlist numeration="upperalpha">
  <listitem><simpara>Some checks must be performed to make sure that
    edge contraction does not modify the topology of the
    mesh.</simpara></listitem>
  <listitem><simpara>Optimal placement strategy can be chosen at run
    time among several choices.</simpara></listitem>
  <listitem><simpara>Boundary edges have to be preserved, otherwise they
    will shrink.  Virtual planes are added perpendicular to triangles at
    boundaries so that vertices can be decimated along those edges, but
    edges are stuck on their boundary.  Garland's thesis dissertation
    contains all informations about this process.</simpara></listitem>
  <listitem><simpara>Weights are added to compute quadrics, as described
    in Garland's dissertation.</simpara></listitem>
  <listitem><simpara>Edges are swapped after being contracted to improve
    triangle quality, as described by Frey in
    <ulink url="http://www.lis.inpg.fr/pages_perso/attali/DEA-IVR/PAPERS/frey00.ps">About Surface Remeshing</ulink>.</simpara></listitem>
</orderedlist>
      </para>
    </section>

    <section id="cls-SmoothNodes3D">
      <title><classname>SmoothNodes3D</classname></title>

      <para>
3D node smoothing.  Triangles are sorted according to their quality,
They are processed iteratively beginning with the worst triangle.
Its three vertices are moved if they have not already been moved
when processing a previous triangle.  A modified Laplacian smoothing
is performed, as briefly explained in
<ulink url="http://www.ann.jussieu.fr/~frey/publications/ijnme4198.pdf">Adaptive Triangular-Quadrilateral Mesh Generation</ulink>, by Houman Borouchaky and
Pascal J. Frey.
For each point <varname>P</varname>, its neighbours <varname>Pi</varname>
are considered.  Instead of moving <varname>P</varname> in the direction
of the barycenter of its neighbours (as is done with Laplacian
smoothing), we compute the position <varname>P'i</varname> on the edge
<code>[PPi]</code> which is at the desired length of <varname>Pi</varname>
and on the same side as <varname>P</varname>.  The barycenter of these
points is a point <varname>P'</varname>, and <varname>P</varname> is
moved to <code>P + alpha PP'</code>.  The <varname>alpha</varname>
constant is a relaxation factor, usually chosen between 0 and 1.
If the final position do not invert triangles, the point is moved.
<remark>TODO: the point should be moved only if triangle quality is
improved.</remark>
<remark>TODO: alternatives should be tested.</remark>
      </para>

      <para>
Example:
<programlisting>
    SmoothNodes3D smooth = new SmoothNodes3D(mesh, 20);
    smooth.compute();
</programlisting>
The second parameter of the constructor is a number of iterations.
Vertex smoothing needs indeed to be processed several times; this
algorithm usually converges slowly.  We need to adjust the number
of iterations and the relaxation factor.
<remark>TODO: the latter is currently hardwired to
<constant>0.1</constant> into
<classname>SmoothNodes3D</classname>.</remark>
      </para>
    </section>

    <section id="cls-SplitEdge">
      <title><classname>SplitEdge</classname></title>

      <para>
Edges are sorted and splitted in turn, the longest edge being processed first.
Example:  if a mesh has already been performed with a target size
of <varname>discr</varname>, the following commands will split edges longer
then <varname>discr</varname>/2:
<programlisting>
    SplitEdge split = new SplitEdge(m, 0.5*discr);
    split.compute();
</programlisting>
<remark>TODO: currently edges longer than sqrt(2)*discr/2 will be
  splitted.</remark>
      </para>

      <para>
When an interior edge is splitted, its midpoint is projected onto the
surface by the <code>Vertex.discreteProject</code> method; if this
projection fails, this edge is not splitted.  It is removed from the
tree because there are few chances that this projection works later.
This means in particular that an interior edge whose endpoints are both
on boundaries cannot be splitted, because discrete projection cannot be
performed on boundary nodes.  As for now, boundary edges are always
splitted, and the new point is in the middle of this edge.
      </para>

      <para>
In all cases, the distance between the newly inserted point and
apical vertices is computed; if it is too low, the edge is not
splitted to avoid bad triangles.
<remark>TODO: edges should be swapped too to improve triangle quality.</remark>
      </para>
    </section>

    </section>
  </chapter>

  <chapter>
    <title>Historical Notes</title>
  <para>
The previous versions described in this chapter are available at
<ulink url="http://cvs.sf.net/viewcvs.py/jcae/jCAE/src/" />
<itemizedlist mark="*">
  <listitem><para><classname>org.jcae.mesh.sd</classname>:
    This first implementation had a clean object-oriented design.
    All simplices (<classname>MeshNode</classname>,
    <classname>MeshEdge</classname> and <classname>MeshFace</classname>)
    inherit from an abstract <classname>MeshElement</classname> class.
    Subclasses implement iterators on adjacent simplices (nodes, edges
    or faces).  Nodes can be defined either on lines (with only one
    parameter), on faces (with two parameters) or directly in 3D space.
    </para>

    <para>Problems:
    <itemizedlist mark="+">
      <listitem><simpara>
        Equality between nodes was performed by comparing coordinates, which
        cause problems due to rounding errors.
      </simpara></listitem>
      <listitem><simpara>
        Equality was implemented recursively: faces were equal if they contain
        equal edges, and edges were equal if their end points are equal.
      </simpara></listitem>
      <listitem><simpara>
        It was very slow, used lots of memory and was thus usable only on very
        small meshes.
      </simpara></listitem>
    </itemizedlist>
    This data structure was designed for general CAD software, and did not
    seem suitable to handle very large meshes.  Profiling revealed that
    all the time was spent in equals() methods.
  </para></listitem>

  <listitem><para><classname>org.jcae.mesh.mesher</classname>: On
  October 2003, we modified our data structure in order to improve
  performance, in particular the equals() method so that
    <orderedlist spacing="compact">
      <listitem><simpara>Coordinates are not evaluated when comparing
        objects.</simpara></listitem>
      <listitem><simpara>These methods are no more
        recursive.</simpara></listitem>
    </orderedlist>
    We kept a standard hierarchy between CAD elements: a
    <classname>MFace2D</classname> is a list of
    three <classname>MEdge2D</classname>, a
    <classname>MEdge2D</classname> contains two endpoints, and a
    <classname>MNode2D</classname> contains two coordinates and the list
    of triangles containing this vertex.
  </para>

    <para>Problems:
    <itemizedlist mark="+">
      <listitem><simpara>
	Many algorithms were using <classname>HashSet</classname> and
	<classname>HashMap</classname> structures.  As a consequence,
	meshes depend on memory location of objects, which means that
	some reported bugs cannot be reproduced.
      </simpara></listitem>
      <listitem><simpara>
	Adjacency relations are not handy. We need to compute
	intersections or unions of the list of triangles bound to a
	vertex.
      </simpara></listitem>
      <listitem><simpara>
	Calls to OpenCascade methods were scattered along all source
	files, so it was very hard to change our CAD engine if we wanted
	to do so.
      </simpara></listitem>
    </itemizedlist></para></listitem>
</itemizedlist>
  </para>

  <para>
Along with changes in data structures, it had also been decided to drop
support of Corba, because its cost in term of development was very
expensive.  Thus on November 2004, a new CVS module,
<code>jCAE-mesher</code>, was created.  In this module
<classname>org.jcae.mesh.mesher</classname> had been replaced by
<classname>org.jcae.mesh.amibe</classname>.
  </para>

  <para>
Our main objectives when designing amibe's data structures were:
<itemizedlist spacing="compact">
  <listitem><simpara>Performance: we want to generate meshes containing
  hundreds of million elements.</simpara></listitem>
  <listitem><simpara>Reproducible: algorithms must not depend on object
  location in memory.</simpara></listitem>
</itemizedlist>
  </para>

  <para>
We preferred performance over genericity, and decided to design our data
structure for a very specific goal: to provide efficient algorithms for
meshing of parametric surfaces,  Our data structure is derived from
Jonathan Richard Shewchuk's work on
<ulink url="http://www.cs.cmu.edu/~quake/triangle.html">Triangle</ulink>
He explains that triangle-based data structures are more efficient than
their edge-based counterparts.  As we were focusing on performance, we
choose such a structure.
  </para>

  <para>
We also had fruitful discussions with FrÃ©dÃ©ric Hecht, who wrote
<ulink url="http://www-rocq1.inria.fr/gamma/cdrom/www/bamg/eng.htm">Bamg</ulink>
and other meshing tools.  He explained that data structure must
be chosen very carefully in order to be able to produce large
meshes, and confirmed that the original one was not suitable.
  </para>

  <para>
Our initial algorithm was:
<orderedlist numeration="upperalpha" inheritnum="inherit">
  <listitem><simpara>Discretization of edges</simpara></listitem>
  <listitem id="item-faces"><para>Discretization of faces based on this boundary
     tessellation.
  <orderedlist numeration="arabic" inheritnum="inherit">
    <listitem><simpara>Compute 2D nodes from edge discretization</simpara></listitem>
    <listitem><simpara>Build an unconstrained Delaunay triangulation containing
        only these nodes</simpara></listitem>
    <listitem><simpara>Tag outer triangles</simpara></listitem>
    <listitem id="item-refine"><simpara>Refine this initial mesh to have a mesh
	compliant with given criteria.  Boundary edges are not modified during
	this stage.</simpara></listitem>
    <listitem><simpara>Store final mesh on disk.  Boundary nodes have a
        reference to the corresponding edge discretization so that boundary
        nodes are not duplicated when gathering all mesh faces
        together.</simpara></listitem>
  </orderedlist></para></listitem>
  <listitem><simpara>Compute 3D coordinates and store mesh on
     disk.</simpara></listitem>
</orderedlist>
  </para>

  <para>
We had many problems with <xref linkend="item-refine"/>.  Our first
implementation was very simple: large edges were split into two edges,
and small edges were contracted.  Sometimes degenerated triangles were
created and could not be removed automatically by contraction or edge
swap.  We translated Jonathan Richard Shewchuk's
<ulink url="http://www.cs.cmu.edu/~quake/robust.html">Fast Robust
Geometric Predicates</ulink> into Java.  Some tests worked better, but
as meshes were dependent on memory location of objects, it was not clear
if this was due to those routines.  Moreover some tests were still
failing.
  </para>

  <para>
FrÃ©dÃ©ric Hecht advised to ensure that no small edges can be created
during this process.  His suggested algorithm was:
<orderedlist numeration="arabic" spacing="compact">
  <listitem><simpara>Store boundary vertices in a quadtree.</simpara></listitem>
  <listitem><para>Loop
  <orderedlist numeration="arabic" inheritnum="inherit">
    <listitem><simpara>For each large edge, compute one or several nodes
       so that all segments have a length greater than the target size,
       and put these candidate nodes in a bucket.</simpara></listitem>
    <listitem><simpara>When all edges are processed, walk through those
       candidate nodes in pseudo-random order (the idea with random walk
       is to avoid inserting all the nodes of an edge, which may prevent
       a near edge to be discretized.  And pseudo so that meshes are
       reproducible), locate the nearest vertex in the mesh with the
       quadtree, and insert this new node if their distance is greater
       than 1/sqrt(2).  The nearest node helps to find in which triangle
       the new vertex is located.  This triangle is split into 3, and
       all edges adjacent to the new vertex are swapped if they are not
       Delaunay.</simpara></listitem>
    <listitem><simpara>Stop when no new nodes can be
       inserted.</simpara></listitem>
  </orderedlist></para></listitem>
</orderedlist>
  </para>

  <para>
This algorithm works very well.  As small edges are never created, there
is no edge contraction, which avoids many problems.  We still have trouble
with some parametrized surfaces, when their parametrization is not C1 or
has large variations.  These problems are due to approximation errors when
computing edge lengths with riemannian metrics, because metrics have large
variations over triangles.  FrÃ©dÃ©ric Hecht suggested to have more accurate
edge length computations by checking metrics on endpoints, and if they
differ too much to add a middle point and process recursively.  This is
of course very costful.  This idea had been implemented in
<classname>Calculus3D</classname>, but did not help (<remark>TODO: maybe it is
buggy?</remark>).  Another idea is to get more information from the CAD engine.
For instance, in <methodname>ConstraintNormal3D</methodname>,
the normal computed by the CAD engine on the middle of an edge is
compared with the 3D normals of its adjacent triangles.  If they are
inverted, this means that a foldover happens in 3D and this edge has to
be swapped.  The <classname>org.jcae.mesh.algos.Smoothing</classname>
algorithm (from the jCAE module, not jCAE-mesher) implemented node
smoothing by using CAD function to project the moved node onto the
surface.  This algorithm may surely be helpful too under these
circumstances.
  </para>
  </chapter>

</book>
